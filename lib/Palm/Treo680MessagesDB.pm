# $Id: Treo680MessagesDB.pm,v 1.1 2008/07/03 17:46:32 drhyde Exp $

package Palm::Treo680MessagesDB;

use strict;
use warnings;

use Palm::Raw();
use DateTime;

use vars qw($VERSION @ISA $timezone $incl_raw);

$VERSION = '1.1';
@ISA = qw(Palm::Raw);
$timezone = 'Europe/London';
$incl_raw = 0;

sub import {
    my $class = shift;
    my %opts = @_;
    $timezone = $opts{timezone} if(exists($opts{timezone}));
    $incl_raw = $opts{incl_raw} if(exists($opts{incl_raw}));
    Palm::PDB::RegisterPDBHandlers(__PACKAGE__, [MsSt => 'MsDb']);
}

=head1 NAME

Palm::Treo680MessagesDB - Handler for Treo SMS message databases

=head1 SYNOPSIS

    use Palm::PDB;
    use Palm::Treo680MessagesDB timezone => 'Europe/London';

    my $pdb = Palm::PDB->new();
    $pdb->Load("MessagesDB.pdb");
    print Dumper(@{$pdb->{records}})'

=head1 DESCRIPTION

This is a helper class for the Palm::PDB package, which parses the database
generated by Palm Treos as a record of all your SMSes.

=head1 OPTIONS

You can set some global options when you 'use' the module:

=over

=item timezone

Defaults to 'Europe/London'.

=item incl_raw

Whether to include the raw binary blob of data in the parsed records.
Only really useful for debuggering, and so defaults to false.

=back

=head1 METHODS

This class inherits from Palm::Raw, so has all of its methods.  The following
are over-ridden, and differ from that in the parent class thus:

=head2 ParseRecord

Returns data structures with the following keys:

=over

=item rawdata

The raw data blob passed to the method.  This is only present if the
incl_raw option is true.

=item date

The date of the message, if available, in YYYY-MM-DD format

=item time

The time of the message, if available, in HH:MM format

=item epoch or timestamp (it's available under both names)

The epoch time of the message.  Note that because the database doesn't
store the timezone, we assume 'Europe/London'.  If you want to change
that, then suppy a timezone option when you 'use' the module.

Internally, this uses the DateTime module.  In the case of ambiguous times
then it uses the latest UTC time.  For invalid local times, the epoch is
set to -1, an impossible number as it's before Palm even existed.

Note that this is always the Unix epoch time.  See L<DateTime> for details
of what this means.

=item name

The name of the other party, which the Treo extracts from the SIM phone-book
or from the Palm address book at the time the call is connected.

=item number or phone

The number of the other party.  This is not normalised so you might see the
same number in different formats, eg 02079813000 and +442079813000.  I may
add number normalisation in the future.

=item direction

Either 'incoming', or 'outgoing'.

=back

Other fields may be added in the future.

=cut

sub ParseRecord {
    my $self = shift;
    my %record = @_;

    $record{rawdata} = delete($record{data});

    my($flags, $date, $time, $duration, $name, $number);
    # the unpack() doesn't seem to work in 5.6.2
    if($] >= 5.008) {
        ($flags, $date, $time, $duration, $name, $number) = unpack(
            'n3N1Z*Z*', $record{rawdata}
        );
    } else {
        # pick the record apart a byte at a time. probably makes horrible
        # charset assumptions, but that's ok, 5.6 doesn't do unicode anyway
        my @bytes = (split(//, $record{rawdata}));
        $flags = 256 * ord($bytes[0]) + ord($bytes[1]);
        $date  = 256 * ord($bytes[2]) + ord($bytes[3]);
        $time  = 256 * ord($bytes[4]) + ord($bytes[5]);
        
        $duration = 0x1000000 * ord($bytes[6]) +
                      0x10000 * ord($bytes[7]) +
                        0x100 * ord($bytes[8]) +
                                ord($bytes[9]);
                                
        ($name, $number) = split(/\x00/, join('', @bytes[10 .. $#bytes]));
    }

    my $year = 1904 + (($date & 0b1111111000000000) >> 9);
    my $month = sprintf('%02d', ($date & 0b111100000) >> 5);
    my $day = sprintf('%02d', $date & 0b11111);
    my $hour = sprintf('%02d', $time >> 8);
    my $minute = sprintf('%02d', $time & 255);

    @record{qw(date time duration name number direction)} = (
        "$year-$month-$day",
        "$hour:$minute",
        $duration,
        $name,
        $number,
        (qw(Incoming Missed Outgoing))[$record{category} - 1]
    );
    $record{epoch} = eval { DateTime->new(
        year => $year,
        month => $month,
        day => $day,
        hour => $hour,
        minute => $minute,
        time_zone => $timezone
    )->epoch(); } || -1;

    delete $record{rawdata} unless($incl_raw);

    return \%record;
}

=head1 LIMITATIONS

The message format is undocumented.  Consequently it has had to be
reverse-engineered.  There appear to be several message formats in
the database, not all of which are handled.

There is currently no support for creating a new database, or for editing
the contents of an existing database.  If you need that functionality,
please submit a patch with tests.  I will *not* write this myself
unless I need it.

Behaviour if you try to create or edit a database is currently undefined.

=head1 BUGS and FEEDBACK

I can only reverse-engineer record formats that appear on my phone, so
there may be some missing.  In addition, I may decode some formats
incorrectly because they're not quite what I thought they were.

If you find any bugs please report them either using
L<http://rt.cpan.org/> or by email.  Ideally, I would like to receive a
sample database and a test file, which fails with the latest version of
the module but will pass when I fix the bug.

=head1 SEE ALSO

L<Palm::SMS>, which handles SMS messages databases on some other models
of Treo, and includes very basic Treo 680 support.

L<Palm::PDB>

L<DateTime>

=head1 AUTHOR

David Cantrell E<lt>F<david@cantrell.org.uk>E<gt>

=head1 COPYRIGHT and LICENCE

Copyright 2008 David Cantrell

This module is free-as-in-speech software, and may be used, distributed,
and modified under the same terms as Perl itself.

=head1 CONSPIRACY

This module is also free-as-in-mason software.

=cut

1;

__END__

sub ParseRecord {
  my $self = shift;
  my %record = @_;
  my @unpack;

  my $smsh;       # each record starts with "SMSh": SMS handler?
  my $unknown1;
  my $timestamp;
  my $unknown2;
  my $name;
  my $firstName;
  my $unknown3;
  my $phone;
  my $folder;
  my $text;

  if ($self->{creator} eq "HsCh") {
    ($smsh,
     $unknown1,
     $timestamp,
     $unknown2,
     $text,
    ) = unpack("a2 A4 N a24 Z* a*", $record{data});
    if ($timestamp eq "") {$timestamp=$EPOCH_1904;}
    else {$timestamp -= 14400;}
    if ($smsh eq "\0\0" ) { $phone="Target"; }
    else { $phone="Me"; }
  } elsif($self->{creator} eq 'MsSt') { # Treo 680
      my $buf = $record{data};
      my $type = 256 * ord(substr($buf, 10, 1)) + ord(substr($buf, 11, 1));
      my($dir, $num, $name, $msg) = ('', '', '', '');
      if($type == 0x400C || $type == 0x4009) { # 4009 not used by 680?
	  $dir = ($type == 0x400C) ? 'inbound' : 'outbound';
	  ($num, $name, $msg) = (split(/\00+/, substr($buf, 34)))[0, 1, 3];
	  $msg = substr($msg, 1);
      } elsif($type == 0) {
#   0x0000 : 00 00 00 00 00 01 00 00 00 02 00 00 00 00 00 03 : ................
#   0x0010 : 00 1B 54 72 73 6D 00 02 00 40 00 11 80 00 C2 8B : ..Trsm...@......
#   0x0020 : 9C 68 00 07 C2 8B 9C 68 00 06 C2 8B 9C 68 00 08 : .h.....h.....h..
#   0x0030 : 00 00 00 00 40 09 00 36 00 00 00 00 00 00 00 00 : ....@..6........
#   0x0040 : 00 00 00 00 00 00 00 00 00 00 00 07 2B 34 34 37 : ............+447
#   0x0050 : 39 34 37 35 37 37 32 36 39 00 45 64 20 42 65 63 : 947577269.Ed.Bec
#   0x0060 : 6B 20 28 4D 29 00 00 00 00 00 00 00 00 00 00 0F : k.(M)...........
#   0x0070 : 00 00 00 00 20 02 00 11 59 6F 75 27 76 65 20 67 : ........You've.g
#   0x0080 : 6F 74 20 6D 61 69 6C 21 00 00 03 00 00 01 4E 40 : ot.mail!......N@
#   0x0090 : 00 00 08 00 00 00 02 00 6C 71 0D                : ........lq.
	  $dir = 'outbound';
	  ($num, $name, $msg) = split(/\00+/, substr($buf, 0x4C), 3);
	  $msg =~ s/^.{9}//s;
	  $msg =~ s/\00.*$//s;

      } elsif($type == 0x0002) {
	  $dir = 'outbound';
	  ($num, $name, $msg) = split(/\00+/, substr($buf, 0x46), 3);
	  $msg =~ s/^.Trsm....//s;
	  $msg =~ s/\00.*$//s;
      } else {
	  printf("UNKNOWN TYPE: 0x%04X\n\n", $type);
	  $type = 'unknown';
      }
      if($type ne 'unknown') {
          print "Offset: $record{offset}\n";
	  printf("Type:   0x%04X\nDir:    %s\nNumber: %s\nName:   %s\nMsg:    %s\n", $type, $dir, $num, $name, $msg);
	  if(!$msg) { print "Buffer:\n".Data::Hexdumper::hexdump(data => $buf) }
	  print "\n";
      } else {
          print "Offset: $record{offset}\n";
	  print "Buffer:\n".Data::Hexdumper::hexdump(data => $buf)."\n\n";
      }
    # ($smsh,
    #  $unknown1,
    #  $timestamp,
    #  $unknown2,
    #  $text,
    # ) = unpack("a2 A4 N a24 Z* a*", $record{data});
    # if ($timestamp eq "") {$timestamp=$EPOCH_1904;}
    # else {$timestamp -= 14400;}
    # if ($smsh eq "\0\0" ) { $phone="Target"; }
    # else { $phone="Me"; }
  } elsif ($record{category} == 0) {
    ### Inbox folder ###
    my $nameFlag;       # whether name and firstName are available
    my $extra;          # temporary string

    ($smsh,
     $unknown1,
     $timestamp,
     $unknown2,
     $phone,
     $extra,
    ) = unpack("A4 a2 N a26 Z* a*", $record{data});

    # unknown2 tells whether name and firstName are available
    $nameFlag = unpack("x7 H", $unknown2);
    if ($nameFlag eq "4") {
      ($name,
       $firstName,
       $extra,
      ) = unpack("Z* Z* a*", $extra);
    }

    # $extra's head contains unknown3 followed by "\d\0"
    ($unknown3, $text) = $extra =~ m/(.*?\d\0)([^\0]+)$/;

  } elsif ($record{category} == 1) {
    ### Sent folder ###
    my $unpack;

    ($smsh,
     $unknown1,
     $timestamp,
     $unknown2,
     $phone,
     $name,
     $firstName,
     $text,
    ) = unpack("A4 a2 N a26 Z* Z* Z* Z*", $record{data});
    $unknown3 = "";

  } elsif ($record{category} == 2) {
    ### Pending folder ###
    die "Never tried to parse a message from Pending folder";

  } else {
    die "Unknown category";

  }

  # Work out common extracted values
  $timestamp -= $EPOCH_1904;

  # Assign extracted values to record
  $record{name}      = $name;
  $record{firstName} = $firstName;
  $record{phone}     = $phone;
  $record{timestamp} = $timestamp;
  $record{folder}    = $record{category};
  $record{text}      = $text;

  $record{smsh}      = $smsh;
  $record{unknown1}  = $unknown1;
  $record{unknown2}  = $unknown2;
  $record{unknown3}  = $unknown3;

  delete $record{data};

  return \%record;
}
